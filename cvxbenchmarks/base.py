import abc

class Problem(object):
    """
    Abstract base class for an object that knows how to read problem
    data and tags from a file or collection of files.
    """
    __metaclass__ = abc.ABCMeta

    @abc.abstractmethod
    def read(self):
        """Returns a list of problems"""
        return NotImplemented

    def tags(self):
        """Returns a set of tags"""
        return []

class Config(object):
    """
    Abstract base class for an object that can be used to configure
    a solver. 
    """
    __metaclass__ = abc.ABCMeta

    def __init__(self, *args, **kwargs):
        pass

    @abc.abstractmethod
    def configure(self):
        """Returns the data necessary to configure the solver"""
        return NotImplemented


class Instance(object):
    """
    Abstract base class for an object that combines a Problem and 
    a Config and:
    1. Checks compatibility of the Problem with the Config.
    2. Can run the config against the problem
       to produce a Results object.
    3. Can be hashed to produce a key (for caching).
    """
    __metaclass__ = abc.ABCMeta

    def __init__(self, problem, config):
        self.problem = problem
        self.config = config

    @abc.abstractmethod

    @abc.abstractmethod
    def run(self):
        """Returns a Results object describing the
        results of running this instance."""
        return NotImplemented

    @abc.abstractmethod
    def check_compatibility(cls, problem, config):
        """Returns True or False depending on whether |problem| is
        compatible with |config| or not"""
        return NotImplemented

    @abc.abstractmethod
    def __hash__(self):
        """Necessary for caching."""
        return NotImplemented

class Results(object):
    """
    Abstract base class for an object that can store data
    generated by the test instance and also manifest that data
    in a useful format.

    Must also provide a way to combine itself with other Results
    objects for easy collection.

    Must be picklable to pass through multiprocessing queues.
    """

    @abc.abstractmethod
    def export(self):
        """Returns (ideally) a pandas DataFrame
        containing the results of this test"""
        return NotImplemented


class Runner(object):
    """
    Base class for an object that can run Instances and
    produce Results.

    Also has access to a cache that can optionally be used
    to control which instances are run.
    """

    def __init__(self, instances, results=None):
        self.instances = instances
        if results is None:
            self.results = []
        else:
            self.results = results



    def run(self):
        for instance in self.instances:
            self.results.append(instance.run())

    def export(self):
        return sum(results) # Calls the __add__ method a bunch

    def __add__(self, other):
        newInstances = list(set(self.instances + other.instances))
        newResults = list(set(self.results + other.results))
        return Runner(newInstances, newResults)

class CacheRunner(Runner):
    """
    Extends the basic framework to support caching.
    """

    def __init__(self, instances, results=None, cache=None):
        super(CacheRunner, self).__init__(instances, results)
        # Initialize cache
        if cache is None:
            self.useCache = False
            self.cache = None
        else:
            self.useCache = True
            self.cache = {}

    def run(self):
        for instance in self.instances:
            if self.cache.contains(instance):
                self.results.append(self.cache[instance])
            else:
                self.results.append(instance.run())

    def __add__(self, other):
        runner = super(CacheRunner, self).__add__(self, other)
        newCache = {}
        newCache.update(self.cache)
        newCache.update(other.cache)
        return CacheRunner(runner.instances,
                           runner.results,
                           newCache)


class Cache(object):
    """
    Abstract base class for an object that can manage the storing and refreshing
    of a cache.
    """

    @abc.abstractmethod
    def load(self):
        return NotImplemented

    @abc.abstractmethod
    def dump(self):
        return NotImplemented

    @abc.abstractmethod
    def contains(self):
        return NotImplemented

    @abc.abstractmethod


    @abc.abstractmethod
    def clear(self):
        return NotImplemented

    @abc.abstractmethod
    def add(self):
        return NotImplemented

    @abc.abstractmethod
    def remove(self):
        return NotImplemented
